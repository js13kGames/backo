<html>
<head>
</head>
<body>
<div id='canvas' style="text-align:center">
<canvas id="game" width="500" height="500"></canvas>
</div>
</body>
<script>
var gameFinished = false;
var current_player_mode = null;
var gameStarted = false;
var flashingTextTimer = 0;
var flashingTextTimer2 = 30;
var canvas = document.getElementById('game');
var ctx = canvas.getContext('2d');
var gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
gradient.addColorStop("0", " magenta");
gradient.addColorStop("0.5", "yellow");
gradient.addColorStop("1.0", "orange");
var emptyImage = new Image();
var characterSpriteDefault = new Image();
var characterSpriteWalking = new Image();
var karambit = new Image();
var baseTile = new Image();
var heart = new Image();
var enemyImage = new Image();
var bossImage = new Image();
var enemyProjectileImage = new Image();
baseTile.src = "assets/1.png"
characterSpriteDefault.src = "assets/3.png"
characterSpriteWalking.src = "assets/4.png"
karambit.src = "assets/8.png"
heart.src = "assets/7.png"
enemyImage.src = "assets/5.png"
bossImage.src = "assets/6.png"
enemyProjectileImage.src = "assets/2.png"
var ImpactXInterval;
var intervalOngoing = false;
class Tile
{
   constructor(x, y)
   {
      this.x = x;
      this.y = y;
      this.w = 25;
      this.h = 25;
   }
}
var tiles = [];
for (var i = 0; i < 500; i += 25) tiles.push(new Tile(i, 475));
var firstTile = tiles[0];
tiles.push(new Tile(firstTile.x - 25, 475));
class Game
{
   constructor()
   {
      this.leftArr = false;
      this.upArrow = false;
      this.rightArr = false;
      this.boss_fight_permission = false;
   }
   drawCanvas()
   {
      if (this.boss_fight_permission)
      {
         var my_gradient = ctx.createLinearGradient(0, 0, 0, 320);
         my_gradient.addColorStop(0, "MediumOrchid");
         my_gradient.addColorStop(1, "darkslategrey");
         ctx.fillStyle = my_gradient;
         ctx.fillRect(0, 0, 500, 500);
      }
      else
      if (current_player_mode == 'beast')
      {
         var my_gradient = ctx.createLinearGradient(0, 0, 0, 320);
         my_gradient.addColorStop(0, "darkblue");
         my_gradient.addColorStop(1, "saddlebrown");
         ctx.fillStyle = my_gradient;
         ctx.fillRect(0, 0, 500, 500);
         return;
      }
      else
      {
         var my_gradient = ctx.createLinearGradient(0, 0, 0, 320);
         my_gradient.addColorStop(0, "darkblue");
         my_gradient.addColorStop(1, "lightblue");
         ctx.fillStyle = my_gradient;
         ctx.fillRect(0, 0, 500, 500);
         return;
      }
   }
   drawTiles()
   {
      if (this.leftArr && !randomTile.hitPlayer && !this.boss_fight_permission)
      {
         var lastTile = tiles[tiles.length - 1];
         tiles.push(new Tile(lastTile.x - 25, 475));
         for (var i = 0; i < tiles.length; i++)
         {
            ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i].x, tiles[i].y, 25, 25);
            tiles[i].x += player.velocity;
         }
      }
      else
         for (var i = 0; i < tiles.length; i++) ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i].x, tiles[i].y, 25, 25);
   }
   checkScore()
   {
      if (player.currentScore == 50)
      {
         randomTile.x = 600;
         this.boss_fight_permission = true;
         enemy.type = 'boss';
         player.power = null;
      }
   }
}
class Player
{
   constructor()
   {
      this.w = 20;
      this.h = 30;
      this.x = 450;
      this.y = 500 - 25 - this.h - 5;
      this.jumpForce = 15;
      this.verticalCollision = false;
      this.horizontalCollision = false;
      this.oldY = 0;
      this.jumpHeight = 90;
      this.velocity = 5;
      this.enemyBounce = false;
      this.playerWasOnTop = false;
      this.lives = 3;
      this.timerForFirstImage = 0;
      this.timerForSecondImage = 0;
      this.hangTime = 5;
      this.stopAscend = false;
      this.currentScore = 0;
      this.power = null;
      this.powerEnderCountdown = 300;
   }
   draw()
   {
      if (this.power == 'invulnerable')
      {
         animatePlayer(characterSpriteDefault, emptyImage, ctx, this.x, this.y, 20, 30);
         return;
      }
      if (game.leftArr && player.power == 'beast')
      {
         if (player.power == 'beast' && game.leftArr)
         {
            animateFlipImage(characterSpriteDefault, characterSpriteWalking, ctx, 20,30);
            return;
         }
         animatePlayer(characterSpriteDefault, characterSpriteWalking, ctx, this.x, this.y, 20,30);
      }
      if (game.leftArr && !randomTile.hitPlayer) animatePlayer(characterSpriteDefault, characterSpriteWalking, ctx, this.x, this.y, 20,30);
      else
      {
         if (player.power === 'beast')
         {
            mirrorImage(ctx, characterSpriteDefault, this.x, this.y, 20,30);
            return;
         }
         ctx.drawImage(characterSpriteDefault, this.x, this.y, 20,30);
      }
   }
   jump()
   {
      if (game.upArrow && this.verticalCollision)
         if (!this.stopAscend)
         {
            this.oldY += this.jumpForce;
            this.y -= this.jumpForce;
         }
   }
   move()
   {
      if (game.boss_fight_permission && game.leftArr && this.x >= 0) this.x -= 2;
      if (game.boss_fight_permission && game.rightArr && this.x + 20 <= 500) this.x += 2;
   }
   ascertainGravity()
   {
      if (!this.verticalCollision && !this.playerWasOnTop) this.y += 5
      if (this.y + 30 >= 475 || this.playerWasOnTop)
      {
         this.jumpHeight = 90;
         this.verticalCollision = true;
         this.oldY = 0;
         this.stopAscend = false;
         this.hangTime = 5;
      }
      else if (this.oldY == this.jumpHeight)
      {
         if (this.hangTime == 0)
         {
            game.upArrow = false;
            this.verticalCollision = false;
         }
         else
         {
            this.stopAscend = true;
            this.hangTime--;
         }
      }
   }
   processLives()
   {
      this.drawLives();
      if (this.lives == 0)
      {
         enemy.x -= 30;
         this.lives = 3;
         gameStarted = false;
         enemy.respawn();
         WaitForStart();
      }
   }
   drawLives()
   {
      for (let i = 1; i <= this.lives; i++) ctx.drawImage(heart, 500 - i * 25, 10, 16, 16);
   }
   powerender()
   {
      if (this.power != null)
      {
         this.powerEnderCountdown--;
         if (this.powerEnderCountdown == 0)
         {
            this.power = null;
            current_player_mode = null;
         }
      }
   }
}
class Projectile
{
   constructor(x, y, w, h)
   {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
      this.ejected = false;
      this.hitEnemy = false;
      this.x_dir = 1;
      this.y_dir = -1
      this.acceleration = 7;
      this.gravityForce = 8;
      this.rotationSpeed = 0;
   }
   draw()
   {
      if (player.power == 'beast')
      {
         this.x = this.x - 20 - 10;
         this.acceleration = 3;
      }
      if (player.power == 'beast') this.acceleration = 7
      if (!this.ejected) ctx.drawImage(karambit, this.x, this.y, this.w, this.h);
      else
      {
         rotateAndPaintImage(ctx, karambit, this.rotationSpeed, this.x, this.y, this.w / 2, this.h / 2, this.w, this.h)
         this.rotationSpeed += 0.3;
      }
   }
   ascertainMovement()
   {
      if (!this.ejected)
      {
         this.x_dir = 1;
         this.y_dir = -1;
         this.x = player.x + 7;
         this.y = player.y + 6;
         return;
      }
      this.x += this.x_dir * this.acceleration;
      this.y += this.y_dir * this.acceleration;
   }
   ascertainCollision()
   {
      if (this.x >= 500) this.x_dir *= -1;
      if (this.x <= (player.power == 'beast' ? 300 : 400) && !game.boss_fight_permission)
      {
         this.y_dir = 0;
         this.y += this.gravityForce;
      }
      if (this.y >= 460)
      {
         this.y_dir = -1;
         this.x_dir = -1;
         this.x = -200;
         this.ejected = false;
      }
      if (game.boss_fight_permission && this.x <= player.x - 100)
      {
         this.y_dir = 0;
         this.y += this.gravityForce
      }
      if (rectCollision(this, randomTile))
      {
         this.y_dir = -1;
         this.x_dir = -1;
         return;
      }
      if (rectCollision(this, enemy))
      {
         if (this.ejected)
         {
            ImpactX(enemy, 15);
            enemy.currentLives--;
            if (enemy.currentLives < 1 && enemy.type !== 'boss') enemy.dead();
            this.ejected = false;
            this.ascertainMovement();
            return;
         }
      }
   }
}
class PowerUp
{
   constructor()
   {
      this.x = -300;
      this.y = 465;
      this.r = 5;
      this.type = null;
      this.spawned = false;
   }
   draw()
   {
      if (this.spawned)
      {
         this.x = randomTile < 0 ? randomTile.x - this.r * 2 : -300;
         if (this.type == 'invulnerable')
         {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'white';
            ctx.stroke();
            ctx.fill();
            this.move();
         }
         else if (this.type == 'beast')
         {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'black';
            ctx.stroke();
            ctx.fill();
            this.move();
         }
      }
   }
   move()
   {
      if (this.y + this.r <= 470) this.y += 5;
      if (game.leftArr && !randomTile.hitPlayer) this.x += player.velocity;
      if (this.x >= 500 + this.r)
      {
         this.spawned = false;
         this.x = -250;
      }
   }
   create_power()
   {
      if (!this.spawned)
      {
         if (game.leftArr && !randomTile.hitPlayer)
         {
            let rng = Math.random();
            if (rng <= 0.005)
            {
               let rngType = Math.random();
               if (rngType >= 0.7) this.type = 'invulnerable'
               else this.type = 'beast';
               this.spawned = true;
            }
         }
      }
      else this.draw();
   }
   check_collision()
   {
      if (this.spawned && rectCollision(this, player))
      {
         player.powerEnderCountdown = 300;
         player.power = this.type;
         current_player_mode = this.type;
         this.spawned = false;
         this.x = -250;
      }
   }
}
class RandomTile
{
   constructor(w, tile)
   {
      this.x = -100;
      this.w = w;
      this.h = 40;
      this.y = 445 - (30 * (this.h / 30 - 1)); //makes sure object is always above ground
      this.tile = tile;
      this.random = 0;
      this.hitPlayer = false;
   }
   appearnow()
   {
      ctx.drawImage(this.tile, this.x, this.y, this.w, this.h);
      if (game.leftArr && !this.hitPlayer) this.x += player.velocity;
      if (this.x > 600) this.disappear();
      if (rectCollision(this, player)) this.hitPlayer = true;
      else this.hitPlayer = false;
   }
   playerOnTop()
   {
      if (Math.abs(this.y - player.y) == 30 && Math.abs(this.x - player.x) < this.w && player.x > this.x - 20 && player.power != 'invulnerable') player.playerWasOnTop = true;
      else if (player.playerWasOnTop)
      {
         player.playerWasOnTop = false;
         if (!game.upArrow)
         {
            game.upArrow = false;
            player.verticalCollision = false;
         }
      }
   }
   disappear()
   {
      this.appear = false;
      this.w = 20 * Math.floor((Math.random() * 5) + 1)
      this.x = enemy.x < 0 ? enemy.x - this.w * 2 : -100;
      this.h = 10 + 10 * Math.floor((Math.random() * 5) + 1);
      this.y = 445 - (30 * (this.h / 30 - 1)); //adjust y to new height
   }
}
class Cloud
{
   constructor(x, y)
   {
      this.cloudX = -300
      this.cloudY = Math.random() * (200 - 50) + 50
   }
   draw()
   {
      ctx.beginPath();
      ctx.moveTo(this.cloudX, this.cloudY);
      ctx.bezierCurveTo(this.cloudX - 40, this.cloudY + 20, this.cloudX - 40, this.cloudY + 70, this.cloudX + 60, this.cloudY + 70);
      ctx.bezierCurveTo(this.cloudX + 80, this.cloudY + 100, this.cloudX + 150, this.cloudY + 100, this.cloudX + 170, this.cloudY + 70);
      ctx.bezierCurveTo(this.cloudX + 250, this.cloudY + 70, this.cloudX + 250, this.cloudY + 40, this.cloudtX + 220, this.cloudY + 20);
      ctx.bezierCurveTo(this.cloudX + 260, this.cloudY - 40, this.cloudX + 200, this.cloudY - 50, this.cloudX + 170, this.cloudY - 30);
      ctx.bezierCurveTo(this.cloudX + 150, this.cloudY - 75, this.cloudX + 80, this.cloudY - 60, this.cloudX + 80, this.cloudY - 30);
      ctx.bezierCurveTo(this.cloudX + 30, this.cloudY - 75, this.cloudX - 20, this.cloudY - 60, this.cloudX, this.cloudY);
      ctx.closePath();
      var grdCenterX = 260;
      var grdCenterY = 80;
      var grd = ctx.createRadialGradient(grdCenterX, grdCenterY, 10, grdCenterX, grdCenterY, 200);
      grd.addColorStop(0, "#F9F2F2");
      grd.addColorStop(1, "#C7B9B9");
      ctx.fillStyle = grd;
      ctx.fill();
      if (game.leftArr && !randomTile.hitPlayer) this.cloudX += player.velocity;
      if (this.cloudX >= 700) this.cloudX = -300;
   }
}
cloud = new Cloud();
class Enemy
{
   constructor()
   {
      this.w = 20 * 2;
      this.h = 30 * 1.5;
      this.x = -250;
      this.y = 500 - 25 - this.h - 5;
      this.maxLives = 2;
      this.currentLives = this.maxLives;
      this.verticalCollision = false;
      this.negativeCollision = false;
      this.decrement_lives_permission = 10;
      this.moving = false;
      this.type = 'normal';
      this.consecutive_kills = 0;
      this.hitTile = false;
      this.direction = Math.random() > 0.50 ? -1 : 1;
      this.appeased = true;
      this.appeasedAmount = 0;
      this.bossWidth = this.w * 2;
      this.bossHeight = this.h * 2;
   }
   draw()
   {
      if (enemy.currentLives >= 1)
         if (enemy.type === 'boss')
         {
            this.w = this.bossWidth;
            this.h = this.bossHeight;
            ctx.drawImage(bossImage, this.x, this.y - this.h / 2, this.w, this.h);
         }
         else
         {
            this.w = this.bossWidth / 2;
            this.h = this.bossHeight / 2;
            ctx.drawImage(enemyImage, this.x, this.y, this.w, this.h);
         }
   }
   fall()
   {
      if (!this.verticalCollision && !player.playerOnTop) this.y += 5;
      if (this.y >= 445 + (30 - this.h)) this.verticalCollision = true;
      else this.verticalCollision = false;
   }
   boss()
   {
      if (rectCollision(this, player)) player.lives = 0;
      if (this.currentLives < 1)
      {
         game.boss_fight_permission = false;
         player.currentScore += 100;
         player.lives++;
         player.x = 450;
         current_player_mode = null;
         this.type = 'normal';
         this.dead();
         return;
      }
   }
   move()
   {
      if (this.type == 'boss')
         if (this.x <= 100) this.x += 5;
      if (game.leftArr && !randomTile.hitPlayer && !game.boss_fight_permission) this.x += player.velocity;
   }
   ascertainCollision()
   {
      if (this.x > 500)
      {
         this.respawn();
         return;
      }
      if (rectCollision(this, randomTile))
      {
         if (intervalOngoing) this.dead();
         clearInterval(ImpactXInterval);
         intervalOngoing = false;
         return;
      }
      if (Math.abs(this.x - player.x) < (this.w > 20 ? this.w : 20) && this.y == player.y + 30 && player.power != 'invulnerable' && this.type != 'boss')
      {
         player.jumpHeight = 180;
         player.verticalCollision = true;
         game.upArrow = true;
         player.stopAscend = false;
         player.hangTime = 5;
         this.dead();
         return;
      }
      if (rectCollision(this, player) && player.power != 'invulnerable')
      {
         ImpactX(randomTile, 15, true);
         ImpactX(enemy, 15, true);
         ImpactX(tiles, 15, true);
         ImpactX(cloud, 15, true);
         ImpactX(powerup, 15, true);
         this.decrement_lives_permission = HitPlayer1(this.decrement_lives_permission);
         return;
      }
      this.decrement_lives_permission = HitPlayer2(this.decrement_lives_permission);
   }
   respawn()
   {
      this.currentLives = this.maxLives;
      this.x = randomTile.x < 0 ? randomTile.x - this.w * 2 : -200;
      this.x = rectCollision(this, randomTile) ? this.x - randomTile.w - this.w : this.x;
      this.y = 500 - this.h - 25;
   }
   healthbar()
   {
      if (this.currentLives != 0)
      {
         ctx.fillStyle = 'gray';
         ctx.fillRect(this.x, enemy.type === 'boss' ? this.y - this.h / 1.5 : this.y - this.h / 3, this.w - this.w / 6, 5);
         if (this.currentLives <= this.maxLives / 2) ctx.fillStyle = 'red';
         else ctx.fillStyle = 'green';
         ctx.fillRect(this.x, enemy.type === 'boss' ? this.y - this.h / 1.5 : this.y - this.h / 3, (this.w - this.w / 6) * ((this.currentLives * 100 / this.maxLives) / 100), 5);
      }
   }
   randomlymove()
   {
      if (!game.boss_fight_permission)
         if (this.appeased && this.appeasedAmount < 10)
         {
            if (rectCollision(this, randomTile)) this.direction *= -1;
            this.x += 2.5 * this.direction;
            this.appeasedAmount++;
         }
         else
         {
            this.direction = Math.random() > 0.35 ? this.direction : this.direction * -1;
            this.appeased = Math.random() < 0.075 ? true : false;
            this.appeasedAmount = 0;
         }
   }
   dead()
   {
      enemyProjectile.ejected = false;
      enemyProjectile.toShootOrNotToShoot = 100;
      this.consecutive_kills++;
      if (this.consecutive_kills == 5)
      {
         player.lives++;
         this.consecutive_kills = 0;
      }
      player.currentScore += 50;
      this.maxLives = enemy.type === 'boss' ? 4 : 2;
      this.currentLives = this.maxLives;
      this.respawn();
   }
}
class Aim
{
   constructor()
   {
      this.x = player.x - 205;
      this.y = 470;
      this.w = 20;
      this.h = 5;
   }
   draw()
   {
      ctx.fillStyle = 'red'
      ctx.globalAlpha = 0.5;
      ctx.fillRect(this.x, this.y, this.w, this.h);
      ctx.globalAlpha = 1.0;
   }
   move()
   {
      if (game.boss_fight_permission) this.x = player.x - (500 - player.x) * 2 - 190 - (450 - player.y);
      else this.x = player.x - (205 + (450 - player.y));
      if (player.power == 'beast') this.x = player.x - (325 + (450 - player.y) * 2)
   }
}
class EnemyProjectile
{
   constructor()
   {
      this.x = enemy.x + enemy.w / 1.5;
      this.y = enemy.y + enemy.h / 1.5;
      this.w = 15;
      this.h = 10;
      this.ejected = false;
      this.toShootOrNotToShoot = 100;
      this.decrement_lives_permission = 10;
   }
   draw()
   {
      if (enemy.currentLives != 0 && this.ejected) ctx.drawImage(enemyProjectileImage, this.x, this.y, this.w, this.h);
   }
   sticktoenemy()
   {
      if (!this.ejected)
      {
         this.x = enemy.x + enemy.w / 1.25;
         this.y = enemy.type === 'boss' ? enemy.y + enemy.h / 6 : enemy.y + enemy.h / 1.5;
      }
   }
   decidetoshoot()
   {
      if (!this.ejected)
      {
         this.toShootOrNotToShoot -= 1;
         if (this.toShootOrNotToShoot < 1) this.ejected = true;
      }
   }
   eject()
   {
      if (this.ejected)
      {
         if (enemy.type == 'boss') this.x += 7
         else this.x += 3;
         if (game.leftArr && !randomTile.hitPlayer)
         {
            this.x += 5;
         }
      }
   }
   reset()
   {
      if (this.x > canvas.width + 50)
      {
         this.ejected = false;
         this.toShootOrNotToShoot = 100;
      }
      if (rectCollision(this, randomTile))
      {
         this.ejected = false;
         this.toShootOrNotToShoot = 100;
      }
   }
   hitplayer()
   {
      if (this.ejected)
      {
         if (rectCollision(this, player) && player.power != 'invulnerable')
         {
            this.decrement_lives_permission = HitPlayer1(this.decrement_lives_permission);
            this.ejected = false;
            this.toShootOrNotToShoot = 100;
         }
         this.decrement_lives_permission = HitPlayer2(this.decrement_lives_permission);
      }
   }
}
game = new Game();

function DeclareGameParameters()
{
   randomTile = new RandomTile(100, baseTile);
   player = new Player();
   enemy = new Enemy();
   projectile = new Projectile(10, 10, 20, 20);
   enemyProjectile = new EnemyProjectile();
   aim = new Aim();
}

function ScoreText()
{
   ctx.font = "35px Impact";
   ctx.fillStyle = gradient;
   ctx.textAlign = "left";
   ctx.fillText("Score: " + player.currentScore, 7, 35);
   if (player.currentScore == 1000)
   {
      gameStarted = false;
      gameFinished = true;
   }
}

function eventHandler()
{
   window.addEventListener('keydown', function(event)
   {
      if (!gameStarted && gameFinished)
      {
         if (event.keyCode == 13) gameFinished = false;
      }
      else if (!gameStarted)
      {
         if (event.keyCode == 13) gameStarted = true;
      }
      else
      {
         if (event.keyCode == 38) game.upArrow = true;
         if (event.keyCode == 32) projectile.ejected = true;
         if (event.keyCode == 37) game.leftArr = true;
         if (event.keyCode == 39) game.rightArr = true;
      }
   }, false);
   window.addEventListener('keyup', function(event)
   {
      if (event.keyCode == 37) game.leftArr = false
      if (event.keyCode == 39) game.rightArr = false;
   }, false);
}

function ImpactX(entity, repetitions, reverse = false)
{
   if (intervalOngoing) return;
   intervalOngoing = true;
   let x = 0;
   ImpactXInterval = window.setInterval(function()
   {
      if (reverse)
      {
         game.upArrow = true;
         player.velocity = -10;
      }
      else
      {
         entity.x -= 10;
      }
      if (++x === repetitions)
      {
         if (reverse) player.velocity = 5;
         intervalOngoing = false;
         window.clearInterval(ImpactXInterval);
      }
   }, 16.6666666667);
}

function animatePlayer(defaultImage, walkingImage, context)
{
   if (player.timerForFirstImage < 5)
   {
      context.drawImage(defaultImage, player.x, player.y, 20, 30);
      player.timerForFirstImage++;
   }
   else if (player.timerForSecondImage < 5)
   {
      context.drawImage(walkingImage, player.x, player.y, 20, 30);
      player.timerForSecondImage++
   }
   else
   {
      context.drawImage(defaultImage, player.x, player.y, 20, 30);
      player.timerForFirstImage = 0
      player.timerForSecondImage = 0;
   }
}

function mirrorImage(ctx, spriteImage, sourceX, sourceY, spriteWidth, spriteHeight)
{
   ctx.save();
   ctx.translate(spriteWidth / 2, spriteHeight / 2 - 15);
   ctx.scale(-1, 1)
   ctx.drawImage(spriteImage, -sourceX, sourceY, spriteWidth, spriteHeight);
   ctx.restore();
}

function animateFlipImage(defaultImage, walkingImage, ctx, spriteWidth, spriteHeight)
{
   if (player.timerForFirstImage < 5)
   {
      ctx.save();
      ctx.translate(spriteWidth / 2, spriteHeight / 2 - 15);
      ctx.scale(-1, 1);
      ctx.drawImage(defaultImage, -player.x, player.y, 20, 30);
      ctx.restore();
      player.timerForFirstImage++;
   }
   else if (player.timerForSecondImage < 5)
   {
      ctx.save();
      ctx.translate(spriteWidth / 2, spriteHeight / 2 - 15);
      ctx.scale(-1, 1);
      ctx.drawImage(walkingImage, -player.x, player.y, 20, 30);
      ctx.restore();
      player.timerForSecondImage++;
   }
   else
   {
      ctx.save();
      ctx.translate(spriteWidth / 2, spriteHeight / 2 - 15);
      ctx.scale(-1, 1);
      ctx.drawImage(defaultImage, -player.x, player.y, 20, 30);
      ctx.restore();
      player.timerForFirstImage = 0;
      player.timerForSecondImage = 0;
   }
}

function EnemyProjectileOrder()
{
   enemyProjectile.hitplayer();
   enemyProjectile.sticktoenemy();
   enemyProjectile.decidetoshoot();
   enemyProjectile.eject();
   enemyProjectile.reset();
   enemyProjectile.draw();
}

function rectCollision(o1, o2)
{
   if (o1 instanceof Player)
   {
      if (o1.x < o2.x && game.leftArr) return false;
      if (o1.power === 'invulnerable') return false;
   }
   if (o2 instanceof Player)
   {
      if (o2.x < o1.x && game.leftArr) return false;
      if (o2.power === 'invulnerable') return false;
   }
   let r1x = o1 instanceof PowerUp ? o1.x - o1.r : o1.x;
   let r1y = o1 instanceof PowerUp ? o1.y - o1.r : o1.y;
   let r1w = o1 instanceof PowerUp ? o1.r : o1.w;
   let r1h = o1 instanceof PowerUp ? o1.r : o1.h;
   let r2x = o2 instanceof PowerUp ? o2.x - o2.r : o2.x;
   let r2y = o2 instanceof PowerUp ? o2.y - o2.r : o2.y;
   let r2w = o2 instanceof PowerUp ? o2.r : o2.w;
   let r2h = o2 instanceof PowerUp ? o2.r : o2.h;
   if (r1x <= r2x + r2w && r1x + r1w >= r2x && r1y < r2y + r2h && r1y + r1h > r2y) return true;
   return false;
}

function rotateAndPaintImage(context, image, angleInRad, positionX, positionY, axisX, axisY, width, height)
{
   context.translate(positionX, positionY);
   context.rotate(angleInRad);
   context.drawImage(image, -axisX, -axisY, width, height);
   context.rotate(-angleInRad);
   context.translate(-positionX, -positionY);
}

function HitPlayer1(decrement_lives_permission)
{
   if (decrement_lives_permission == 10)
   {
      player.lives--;
      decrement_lives_permission--;
   }
   return decrement_lives_permission;
}

function HitPlayer2(decrement_lives_permission)
{
   if (decrement_lives_permission == 0) decrement_lives_permission = 10;
   if (decrement_lives_permission != 10) decrement_lives_permission--;
   return decrement_lives_permission;
}

function EnemyOrder()
{
   enemy.draw();
   enemy.healthbar();
   if (game.boss_fight_permission) enemy.boss();
   enemy.fall();
   enemy.move();
   enemy.ascertainCollision();
   enemy.randomlymove();
}

function ProjectileOrder()
{
   projectile.ascertainMovement();
   projectile.ascertainCollision();
   projectile.draw();
}

function PlayerOrder()
{
   player.ascertainGravity();
   player.jump();
   player.move();
   player.draw();
   player.processLives();
   player.powerender()
}

function GameFinishedScreen()
{
   var my_gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
   my_gradient.addColorStop("0", " magenta");
   my_gradient.addColorStop("0.5", "yellow");
   my_gradient.addColorStop("1.0", "purple");
   ctx.fillStyle = "red";
   ctx.textAlign = "center";
   ctx.fillText("Game finished!", canvas.width / 2, canvas.height / 2 - 100);
   ctx.fillText("Press Enter to restart!", canvas.width / 2, canvas.height / 2);
}

function StartScreenText()
{
   ctx.fillStyle = "brown";
   ctx.textAlign = "center";
   ctx.font = "20px Impact";
   ctx.fillText("Use arrow keys to move!", 105, 300);
   ctx.fillText("Press Space to jump!", 400, 300);
   ctx.fillText("Power ups:", 250, 350)
   ctx.beginPath();
   ctx.arc(130, 380, 5, 0, 2 * Math.PI, false);
   ctx.fillStyle = 'white';
   ctx.stroke();
   ctx.fill();
   ctx.fillStyle = "lightyellow";
   ctx.fillText("- Player becomes Ethereal!", 250, 387)
   ctx.beginPath();
   ctx.arc(130, 410, 5, 0, 2 * Math.PI, false);
   ctx.fillStyle = 'black';
   ctx.stroke();
   ctx.fill();
   ctx.fillText("- Player gains Beast Mode!", 250, 417)
   ctx.fillStyle = "brown";
   ctx.fillText("Objective:", 250, 450)
   ctx.fillStyle = "brown";
   ctx.fillText("Destroy everything in your path!", 250, 480)
}

function WaitForStart()
{
   if (!gameFinished)
   {
      game.boss_fight_permission = false;
      current_player_mode = null;
      ctx.font = "35px Impact";
      var my_gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      my_gradient.addColorStop("0", " magenta");
      my_gradient.addColorStop("0.5", "yellow");
      my_gradient.addColorStop("1.0", "purple");
      ctx.fillStyle = my_gradient;
      ctx.textAlign = "center";
      ctx.fillText("Backo", canvas.width / 2, canvas.height / 2 - 100);
      my_gradient = ctx.createLinearGradient(0, 0, 320, 0);
      ctx.fillStyle = "red";
      ctx.textAlign = "center";
      if (flashingTextTimer < 30)
      {
         ctx.fillText("PRESS ENTER TO START!", canvas.width / 2, canvas.height / 2);
         flashingTextTimer++;
      }
      else if (flashingTextTimer2 > 0)
      {         
      	 my_gradient.addColorStop("0", " magenta");
         my_gradient.addColorStop("0.5", "orange");
         my_gradient.addColorStop("1.0", "blue");
         ctx.fillStyle = "lightyellow";
         ctx.fillText("PRESS ENTER TO START!", canvas.width / 2, canvas.height / 2);
         flashingTextTimer2--;
      }
      else
      {
         ctx.fillStyle = "red";
         ctx.fillText("PRESS ENTER TO START!", canvas.width / 2, canvas.height / 2);
         flashingTextTimer = 0;
         flashingTextTimer2 = 30;
      }
      StartScreenText()
      DeclareGameParameters();
   }
   else GameFinishedScreen();
}
powerup = new PowerUp();

function recurring()
{
   game.drawCanvas();
   if (!gameStarted) WaitForStart();
   else
   {
      game.checkScore();
      game.drawTiles();
      aim.draw();
      aim.move();
      if (!game.boss_fight_permission)
      {
         powerup.create_power();
         powerup.check_collision();
         cloud.draw();
         randomTile.appearnow();
      }
      EnemyProjectileOrder();
      EnemyOrder();
      PlayerOrder();
      ProjectileOrder();
      ScoreText();
      randomTile.playerOnTop();
   }
}
setInterval(recurring, 16.6666666667);
eventHandler();
</script>
</html>