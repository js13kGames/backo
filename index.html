<html>
	<head>
		<style>
			#canvas {
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div id='canvas'>
			<canvas id="game" width="500" height="500"></canvas>
		</div>
	</body>
	<script>
	// GameState variables
	var gameStarted = false;
	var flashingTextTimer = 0; //se koristat vo WaitForStart() za broenje na ciklusi
	var flashingTextTimer2 = 30;
	// Canvas Globals
	var canvas = document.getElementById('game');
	var ctx = canvas.getContext('2d');
    //color gradient
	var gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop("0"," magenta");
        gradient.addColorStop("0.5", "yellow");
        gradient.addColorStop("1.0", "orange");
	// Image Globals
	var emptyImage = new Image();
	var characterImage = new Image();
	var characterSpriteDefault = new Image();
	var characterSpriteWalking = new Image();
	var karambit = new Image();
	var baseTile = new Image();
	var baseTile2 = new Image();
	var openingSlopeTile = new Image();
	var closingSlopeTile = new Image();
	var hostileInteractable = new Image();
	var neutralInteractable = new Image();
	var beneficialInteractable = new Image();
	var heart = new Image();
	heart.src = "../js13kgames_entry/tiles/heart.png"
	baseTile.src = "../js13kgames_entry/tiles/2.png";
	baseTile.src = "../js13kgames_entry/tiles/1.png";
	openingSlopeTile.src = "../js13kgames_entry/tiles/3.png";
	closingSlopeTile.src = "../js13kgames_entry/tiles/4.png";
	hostileInteractable.src = "../js13kgames_entry/tiles/hostile.png";
	neutralInteractable.src = "../js13kgames_entry/tiles/neutral.png";
	beneficialInteractable.src = "../js13kgames_entry/tiles/beneficial.png";
	characterImage.src = "../js13kgames_entry/tiles/character.png";
	characterSpriteDefault.src = "../js13kgames_entry/tiles/karakter 1.png";
	characterSpriteWalking.src= "../js13kgames_entry/tiles/karakter 2.png";
	karambit.src = "../js13kgames_entry/tiles/karambit.png";

	// Uncatogorized Globals
	var ImpactXInterval;
	var intervalOngoing = false;

	class Tile {
		constructor(x,y,type){
			this.x=x;
			this.y=y;
			this.type=type;
			this.w=25;
			this.h=25;
		}
	}
	var tiles = [];					
	for (var i = 0; i < 500; i += 25)
		tiles.push(new Tile(i,475,'basic'));				//pushing the initial tiles to the array so they can be drawn immediately
	var firstTile = tiles[0];
	tiles.push(new Tile(firstTile.x - 25, 475, 'basic'));

	class Game 
	{
		constructor(canvas_width, canvas_height) 
		{
			this.gravity = true;
			this.status = 2; // 0 intro, 1 menu (selection), 2 gameplay, 3 menu during gameplay
			this.leftArr = false;
			this.upArrow = false;
			this.slope = false;
			this.canvas_width = canvas_width;
			this.canvas_height = canvas_height;
			this.primitive_tile_width = 25;
			this.primitive_tile_height = 25;
			this.className = 'Game';
		}
		drawCanvas() 
		{
			var my_gradient = ctx.createLinearGradient(0, 0, 0, 320);
			my_gradient.addColorStop(0, "darkblue");
			my_gradient.addColorStop(1, "lightblue");
			ctx.fillStyle = my_gradient;
			ctx.fillRect(0, 0, this.canvas_width, this.canvas_height);
		}
		drawTiles() 
		{
			if (this.leftArr && !randomTile.hitPlayer) //now stops moving when playa is hit by obstacle
			{ 
				var lastTile = tiles[tiles.length - 1];
				tiles.push(new Tile(lastTile.x - this.primitive_tile_width, 475, 'basic'));
				for (var i = 0; i < tiles.length; i++) 
				{
					ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i].x, tiles[i].y, this.primitive_tile_width, this.primitive_tile_height);
					tiles[i].x += player.velocity; 
				}

				// for (var i = 0; i < tiles.length; i++) 
				// {
				// 	if(tiles[i].x <= -100 || tiles[i].x >= 600)			//removing elements from the tiles array;
				// 		tiles.splice(i,1);								//causes bug
				// }
			} 
			else
				for (var i = 0; i < tiles.length; i++)
					ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i].x, tiles[i].y, this.primitive_tile_width, this.primitive_tile_height);
		}  
	}
	class Interactable 
	{
		constructor(status) 
		{
			this.x = parseInt(Math.random() * (400 - 100) + 100);
			this.y = parseInt(Math.random() * (400 - 100) + 100);
			this.status = status; // beneficial, neutral, hostile
			this.className = 'Interactable';
		}
		draw() 
		{
			if (this.status == 'hostile') 
				ctx.drawImage(hostileInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
			if (this.status == 'netural') 
				ctx.drawImage(neutralInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
			if (this.status == 'beneficial') 
				ctx.drawImage(beneficialInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
		}
		ascertainCollision() 
		{
		}
		ascertainMovement()
		{
			
		}
	}
	class Player 
	{
		constructor() 
		{
			this.health = 100;
			this.w = 20;
			this.h = 30;
			this.x = 450;
			this.y = game.canvas_height - game.primitive_tile_height - this.h - 5;
			this.jumpForce = 15;
			this.verticalCollision = false;
			this.horizontalCollision = false;
			this.oldY = 0; 
			this.jumpHeight = 90;
			this.velocity = 5;
			this.gravityForce = 5;
			this.className = 'Player';
			this.enemyBounce = false;
			this.playerWasOnTop = false; //tells the player if he is on top of an object
			this.lives=3;
			this.timerForFirstImage=0; //used in animation function to store the number of cycles the current image has been active
			this.timerForSecondImage=0;
			this.hangTime = 5; //set to 5 also in lines 420 196
			this.stopAscend = false;
			this.currentScore = 0;
			this.scorePerKill = 50;
			this.power = null;
		}
		draw() 
		{
			if(this.power == 'invulnerable') {
				animatePlayer(characterSpriteDefault, emptyImage, ctx, this.x,this.y,this.w,this.h); // player blinks when invulnerable
				return;
			}

			if(game.leftArr && !randomTile.hitPlayer) // if player "moving" do the animation
			    animatePlayer(characterSpriteDefault, characterSpriteWalking, ctx, this.x,this.y,this.w,this.h);
			else
				ctx.drawImage(characterSpriteDefault,this.x,this.y,this.w,this.h);
		}
		jump() 
		{
			if (game.upArrow && this.verticalCollision) 
			{
				if (!this.stopAscend) // ascend untill reaching jump height
				{
					this.oldY += this.jumpForce;
				    this.y -= this.jumpForce;	
				} 
			}
		}
		ascertainGravity() 
		{
			if (!this.verticalCollision && !this.playerWasOnTop) //Fall if player not on ground or on top of object
			{
				this.y += 5
			}
			if (this.y+this.h >= 475 || this.playerWasOnTop) //stop falling if on ground or on object
			{
				this.jumpHeight = 90;
				this.verticalCollision = true;
				this.oldY = 0;
				this.stopAscend=false;
				this.hangTime=5; 
				
			} 
			else if (this.oldY === this.jumpHeight) //stop ascending when reaching max jump height
			{
				if (this.hangTime == 0)
				{
					game.upArrow = false;
				    this.verticalCollision = false;
				}
				else 
				{
					this.stopAscend=true;
					this.hangTime--;
				}
			}
		}
		processLives(){
			this.drawLives();
		}
		drawLives(){
			for(let i = 1; i <= this.lives; i++)
				ctx.drawImage(heart,game.canvas_width - i*25,10,16,16);
		}
		addtoscore() {
			this.currentScore += this.scorePerKill;
		}
	}
	class Projectile 
	{
		constructor(x, y, w, h) 
		{
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;
			this.ejected = false;
			this.hitEnemy = false;
			this.x_dir = 1;
			this.y_dir = -1
			this.acceleration = 7;
			this.gravityForce = 8;
			this.rotationSpeed=0;
			this.className = 'Projectile';
					}
		draw() 
		{
			if (this.ejected)
			{
				rotateAndPaintImage(ctx,karambit,this.rotationSpeed,this.x,this.y,this.w/2,this.h/2,this.w,this.h)
				this.rotationSpeed+=0.3;
			}
			else
			ctx.drawImage(karambit, this.x, this.y, this.w, this.h);	
		}
		ascertainMovement()
		{
			if (!this.ejected) 
			{
				this.x_dir = 1;
				this.y_dir = -1;
				this.x = player.x+7; //ball stays on top of player
				this.y = player.y+6;
				return;
			}
			this.x += this.x_dir * this.acceleration;
			this.y += this.y_dir * this.acceleration;
		}
		ascertainCollision()
		{
            if(this.x >= game.canvas_width)
				this.x_dir *= -1;						// bounce off of right wall

			if(this.x <= 400){
				this.y_dir = 0;						// apply gravity when it reaches a certain point
				this.y += this.gravityForce;
			}
			if(this.y >= 460){
				this.ejected = false;				// dissapear when it touches the ground
			}

			if (Math.sign(Math.abs(this.x - randomTile.x)) && Math.abs(this.x - randomTile.x) < (this.w > randomTile.w ? this.w : randomTile.w) && this.y >= randomTile.y) // if hits a random tile
			{
				this.y_dir = -1;
				this.x_dir = -1; 
				return;
			}

			if (!Math.sign(Math.abs(this.x - randomTile.x)) && Math.abs(this.x - randomTile.x) < (this.w > randomTile.w ? this.w : randomTile.w) && this.y >= randomTile.y) // if hits a random tile
			{
				this.ejected = false;
				return;
			}

			
			if (Math.abs(this.x - enemy.x) < (this.w > enemy.w ? this.w : enemy.w) && this.y > enemy.y) // if hits an enemy
			{ 
				enemy.negativeCollision = true;
				this.y_dir=-1;		
				return;
			}
		}
	}
	class Power {
		constructor(){
			this.x=-100;
			this.y=350;
			this.r=13;
			this.type = null; // #1 invulnerable player, #2 player turns around, can shoot straight, and kills enemies with 1 shot
			this.spawned = false;
		}
		draw(){
			if(this.spawned) {
				if(this.type == 'invulnerable') {			// invulnerable player
					ctx.beginPath();						// can't be touched by enemies, no collision whatsoever
		      		ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
		      		ctx.fillStyle = 'white';
		      		ctx.stroke();
		      		ctx.fill();

		      		this.move();
	      		}
	      		else if (this.type == 'beast')  {			// beast player
	      			ctx.beginPath();						// player turns around, shoots straight and kills enemies with 1 shot
		      		ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
		      		ctx.fillStyle = 'black';
		      		ctx.stroke();
		      		ctx.fill();

		      		this.move();
	      		}
			}
			
		}
		move(){
			if(this.y + this.r <= 475)			// fall on the ground	
				this.y+=5;
			if (game.leftArr && !randomTile.hitPlayer)	// move right
      			this.x+=5;

      		if(this.x >= 800) {				// when the current power gets out of bounds, another one can be spawned 
      			this.spawned = false; 
      			this.x = -100;
      		}
		}
		create_power(){

			if(!this.spawned) {
				if (game.leftArr && !randomTile.hitPlayer) { 
					let rng = Math.random();
					if(rng <= 0.005) {
						let rngType = Math.random();
						if(rngType >= 0)
							this.type = 'invulnerable'
						else
							this.type = 'beast';

						this.spawned = true;
					}
				}
			} else 
				this.draw();
		}
		check_collision(){
			if(this.x+this.r >= player.x && 
				this.x+this.r <= player.x + player.w &&				// collision detection
				player.y == game.canvas_height - game.primitive_tile_height - player.h) {
					player.power = this.type;
					this.spawned = false; 				// power dissapears,
					this.x = -100;						// player gains the power
			}
		}

	}
	class RandomTile 
	{
		constructor(w, tile) 
		{
			this.x = -100;
			this.w = w;
			this.h = 40; // random object height
			this.y = 445 - (30 * (this.h / 30 - 1)); //makes sure object is always above ground
			this.tile = tile;
			this.random = 0;
			this.hitPlayer = false;
			this.className = 'RandomTile';	
		}

		appearnow() 
		{
			ctx.drawImage(this.tile, this.x, this.y, this.w, this.h);
			if (game.leftArr && !this.hitPlayer) this.x += player.velocity;

			if (this.x > 600)
			{
				this.appear = false; //appearn() will stop being called
				this.w=20 * Math.floor((Math.random()*5)+1) //must be bigger than 20 and divisible by 20
				this.x = -100; // reset at original position on the left
				this.h = 10+10*Math.floor((Math.random()*5)+1); //new object height //must at least 20 and divisible by 10
				this.y = 445 - (30 * (this.h / 30 - 1)); //adjust y to new height   
			}
			if (Math.abs(this.x - player.x) == this.w   && player.x > this.x && player.power != 'invulnerable') //when player and object collide on x axis
			{
				if (player.y + player.h / 2 > (this.y - this.h / 2)) this.hitPlayer = true; // if player isnt in the air over the obstacle
				else this.hitPlayer = false;
			}
		}
		playerOnTop() 
		{
			if (Math.abs(this.y - player.y) == 30 && Math.abs(this.x - player.x) < this.w &&player.x > this.x-20 && player.power != 'invulnerable')
				player.playerWasOnTop = true;
			else if (player.playerWasOnTop) 
			{
				player.playerWasOnTop = false;
				if (!game.upArrow) 
				{
					game.upArrow = false;
					player.verticalCollision = false;
				}
			}
		}
	}
	class Cloud {
		constructor(x,y){
			this.cloudX = -300
			this.cloudY = Math.random() * (200 - 50) + 50
		}
		draw(){
	            ctx.beginPath();
	            ctx.moveTo(this.cloudX, this.cloudY);
	            ctx.bezierCurveTo(this.cloudX - 40, this.cloudY + 20, this.cloudX - 40, this.cloudY + 70, this.cloudX + 60, this.cloudY + 70);
	            ctx.bezierCurveTo(this.cloudX + 80, this.cloudY + 100, this.cloudX + 150, this.cloudY + 100, this.cloudX + 170, this.cloudY + 70);
	            ctx.bezierCurveTo(this.cloudX + 250, this.cloudY + 70, this.cloudX + 250, this.cloudY + 40, this.cloudtX + 220, this.cloudY + 20);
	            ctx.bezierCurveTo(this.cloudX + 260, this.cloudY - 40, this.cloudX + 200, this.cloudY - 50, this.cloudX + 170, this.cloudY - 30);
	            ctx.bezierCurveTo(this.cloudX + 150, this.cloudY - 75, this.cloudX + 80, this.cloudY - 60, this.cloudX + 80, this.cloudY - 30);
	            ctx.bezierCurveTo(this.cloudX + 30, this.cloudY - 75, this.cloudX - 20, this.cloudY - 60, this.cloudX, this.cloudY);
	            ctx.closePath();

	            var grdCenterX = 260;
	            var grdCenterY = 80;
	            var grd = ctx.createRadialGradient(grdCenterX, grdCenterY, 10, grdCenterX, grdCenterY, 200);
	            grd.addColorStop(0, "#F9F2F2"); // light blue
	            grd.addColorStop(1, "#C7B9B9"); // dark blue
	            ctx.fillStyle = grd;
	            ctx.fill();


            if (game.leftArr && !randomTile.hitPlayer) //now stops moving when playa is hit by obstacle
            	this.cloudX+=5;

            if(this.cloudX >= 700)
            	this.cloudX = -300;
            
		}
	}
	cloud = new Cloud();
	class Enemy 
	{
		constructor() 
		{
			this.w = player.w * 2;
			this.h = player.h * 1.5;
			this.x = 250;
			this.y = game.canvas_height - game.primitive_tile_height - this.h - 5;
			this.maxLives=3;
			this.currentLives = this.maxLives;
			this.verticalCollision = false;
			this.negativeCollision = false;
			this.className = 'Enemy';
			this.decrement_lives_permission = 10; //fie
			//random movement
			this.randomXdir = -1;
			this.randomMovement=0;
			this.moving = false;
			this.randomMovementCountdown = 10;
		}
		draw() 
		{
			if(enemy.currentLives != 0){
				ctx.fillStyle = 'black';
				ctx.fillRect(this.x, this.y, this.w, this.h)
			}
			
		}
		fall() 
		{
			if (!this.verticalCollision && !player.playerOnTop) 
			{
				this.y += 5;			//gravity pull
			}
			if (this.y >= 445 + (30 - this.h)) 
				this.verticalCollision = true;
			else 
				this.verticalCollision = false;
		}
		move() 
		{
			if (game.leftArr && !randomTile.hitPlayer)
				this.x += player.velocity;
		}
		ascertainCollision() 
		{
			if (this.x > 500)
			{
				this.respawn();
				return;
			}
			
			if (this.negativeCollision && projectile.ejected) // projectile collision
			{
				projectile.ejected = false;
				this.negativeCollision = false;
				this.currentLives--;
				if (this.currentLives < 1)
				{
					player.addtoscore();
					return this.respawn();
				}	
				ImpactX(enemy, 15);
				return;
			}
			
			if (Math.abs(this.x - randomTile.x) <= (this.w > randomTile.w ? this.w : randomTile.w)) // random tile collision
			{
				clearInterval(ImpactXInterval);
				intervalOngoing = false;
				return;
			} 

			if (Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y == player.y + player.h && player.power != 'invulnerable') // player Y collision causes a bounce
			{
				player.jumpHeight = 180;
				player.verticalCollision = true;
				game.upArrow = true;
				player.stopAscend=false;
				player.hangTime=5; 
				enemy.currentLives = 0;
				player.addtoscore();
				this.respawn();
				return;
			}
			
			if (Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y < player.y + player.h && player.power != 'invulnerable') // player X collision
			{
				ImpactX(randomTile, 15, true);
				ImpactX(enemy, 15, true);
				ImpactX(tiles, 15, true);

				this.decrement_lives_permission = HitPlayer1(this.decrement_lives_permission);
				
				return;
			}

			if(player.lives == 0) {
					enemy.x -= 30;
					player.lives = 3;
					gameStarted = false;
					this.respawn();
					WaitForStart();
			}

			this.decrement_lives_permission= HitPlayer2(this.decrement_lives_permission);

		}
		respawn() 
		{
			this.x = randomTile.x - 200;
			this.y = game.canvas_height - this.h - game.primitive_tile_height;
			this.currentLives = this.maxLives;
		}

		healthbar()
		{
			if(this.currentLives != 0){
				ctx.fillStyle = 'gray';
				ctx.fillRect(this.x, this.y-this.w/3, this.w, 10);
				if (this.currentLives == 1)
					ctx.fillStyle = 'red';
				else ctx.fillStyle = 'green';
				ctx.fillRect(this.x, this.y-this.w/3, this.w * ((this.currentLives*100/this.maxLives)/100), 10);
			}
			
		}
		randomlymove()
		{
			this.randomMovement = Math.random()*50+1;
			if (this.randomMovement>48.9)
			{
				this.moving=true;
				this.randomMovementCountdown=10;
			}

			if (Math.abs(this.x - randomTile.x) <= (this.w > randomTile.w ? this.w : randomTile.w)) 
			{
				this.randomXdir *=-1
				this.x += 7*this.randomXdir;
			}
			
			else if(this.moving && this.randomMovementCountdown > 0)
			{
				this.x += 3*this.randomXdir;
				this.randomMovementCountdown--;
			}
			else 
			{
				this.moving=false;
				this.randomMovementCountdown=50;
				this.randomXdir *= -1;
			}
		}
	}
	class EnemyProjectile
	{
		constructor()
		{
			this.x=enemy.x;
			this.y=enemy.y;
			this.w=enemy.w/3;
			this.h=enemy.h/3;
			this.ejected=false;
			this.toShootOrNotToShoot=100;
			this.decrement_lives_permission=10;
              
		}
		draw()
		{
			if(enemy.currentLives != 0){
				ctx.fillStyle='black';
				ctx.fillRect(this.x,this.y,this.w,this.h);
			}
		}
		sticktoenemy()
		{
			if(!this.ejected)
			{
				this.x=enemy.x;
			this.y=enemy.y+10;
			}
		}
		decidetoshoot()
		{
			if(!this.ejected)
			{
				this.toShootOrNotToShoot -= 1;
			    if (this.toShootOrNotToShoot < 1)
			        this.ejected=true;
			}
		}
		eject()
		{
			if (this.ejected)
			{
				this.x +=3;
				if (game.leftArr && !randomTile.hitPlayer)
				{
					this.x+=5;
				}
			}
		}
		reset()
		{
			if (this.x > canvas.width +50)
			{
				this.ejected=false;
				this.toShootOrNotToShoot=100;
			}
			
		}
		hitplayer()
		{
			if (this.ejected)
	     	{
		 		if ((Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y < player.y + player.h) && player.power != 'invulnerable')
		    	{
			    	if (Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y < player.y + player.h && player.power != 'invulnerable') 
		     	    {
						this.decrement_lives_permission=HitPlayer1(this.decrement_lives_permission);
				    }

					this.ejected=false;
					this.toShootOrNotToShoot=100;
			    }
			    this.decrement_lives_permission=HitPlayer2(this.decrement_lives_permission);
		   	}
		}
	}
	game = new Game(500, 500);
	function DeclareGameParameters()
	{
	    randomTile = new RandomTile(100, baseTile);
	    player = new Player();
	    enemy = new Enemy();
     	projectile = new Projectile(10, 10, 20, 20);
	    enemyProjectile = new EnemyProjectile();
	    
	}
	
    function ScoreText()
	{
		ctx.font = "35px Impact";
		ctx.fillStyle = gradient;
		ctx.textAlign = "left";
		ctx.fillText("Score: " + player.currentScore, 7, 35); 
	}

	function eventHandler() 
	{
		window.addEventListener('keydown', function(event) 
		{
			if (!gameStarted)
			{
				if (event.keyCode == 13) // start game when pressing enter
				    gameStarted = true;
			}
			else
			{
			if (event.keyCode == 38) // up
			{
				game.upArrow = true;
			}
			if (event.keyCode == 32) // space
			{
				projectile.ejected = true;
			}
			if (event.keyCode == 37) // left
			{
				game.leftArr = true;
	 		}
			}
		}, false);
		window.addEventListener('keyup', function(event) 
		{
			if (event.keyCode == 37) // left
			{
				game.leftArr = false
			}

		}, false);
	}

	function ImpactX(entity, repetitions, reverse = false) 
	{
		if (intervalOngoing) return;
		intervalOngoing = true;
		let x = 0;
		ImpactXInterval = window.setInterval(function () 
		{
			if (reverse) 
			{
				game.upArrow = true;
				player.velocity = -10;
			}
			else 
			{
				entity.x -= 10;
			}

			if (++x === repetitions) 
			{
				if (reverse) player.velocity = 5;

				intervalOngoing = false;
				window.clearInterval(ImpactXInterval);
			}
		}, 16.6666666667);
	}
	
	function animatePlayer( defaultImage, walkingImage, context) {
	  if(player.timerForFirstImage<5) {  //crta prvata slika 5 ciklusi
	    context.drawImage(defaultImage,player.x,player.y,player.w,player.h);
		player.timerForFirstImage++;
	  }
	  else if(player.timerForSecondImage<5) { //crta vtorata slika 5 ciklusi
	    context.drawImage(walkingImage,player.x,player.y,player.w,player.h);
		player.timerForSecondImage++
	  }
	  else { //resetira, so sho ke pocni da ja crta prvata slika povtorno
		context.drawImage(defaultImage,player.x,player.y,player.w,player.h);
		player.timerForFirstImage=0
		player.timerForSecondImage=0;
	  }		
	}

	function EnemyProjectileOrder()
	{
		enemyProjectile.hitplayer();
		enemyProjectile.sticktoenemy();
		enemyProjectile.decidetoshoot();
		enemyProjectile.eject();
		enemyProjectile.reset();
		enemyProjectile.draw();
	}

	function rotateAndPaintImage ( context, image, angleInRad , positionX, positionY, axisX, axisY, width, height ) 
	{
        context.translate( positionX, positionY );
        context.rotate( angleInRad );
        context.drawImage( image, -axisX, -axisY, width, height );
        context.rotate( -angleInRad );
        context.translate( -positionX, -positionY );
	}
	function HitPlayer1(decrement_lives_permission)
	{
		if(decrement_lives_permission == 10) {
					player.lives --;		
					decrement_lives_permission--;
				}
		return decrement_lives_permission;
	}
	function HitPlayer2(decrement_lives_permission)
	{
		if(decrement_lives_permission == 0)
				decrement_lives_permission = 10;					//fixes the bug that took 2 lives instead of 1
			if(decrement_lives_permission != 10)
				decrement_lives_permission--;
		return decrement_lives_permission;
	}
	function EnemyOrder() 
	{
		enemy.draw();
		enemy.healthbar();
		enemy.fall();
		enemy.move();
		enemy.ascertainCollision();
		enemy.randomlymove();
	}
	function ProjectileOrder() 
	{
		projectile.ascertainMovement();
		projectile.ascertainCollision();
		projectile.draw();
	}
	function PlayerOrder() 
	{
		player.ascertainGravity();
		player.jump();
		player.draw();
		player.processLives();
	}
	function WaitForStart()
	{
		ctx.font = "35px Impact";
		//ime na gejm text
        var my_gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
		my_gradient.addColorStop("0"," magenta");
		my_gradient.addColorStop("0.5", "yellow");
		my_gradient.addColorStop("1.0", "purple");
		ctx.fillStyle = my_gradient;
		ctx.textAlign = "center";
        ctx.fillText("Ime na gejmot", canvas.width/2, canvas.height/2-100); 
		//start game text
		my_gradient = ctx.createLinearGradient(0, 0, 320, 0);
		ctx.fillStyle = my_gradient;
        ctx.textAlign = "center";
		if (flashingTextTimer < 30) //edna boja 30 ciklusi
		{
			my_gradient.addColorStop("0"," magenta");
		    my_gradient.addColorStop("0.5", "yellow");
		    my_gradient.addColorStop("1.0", "purple");
			ctx.fillText("Click Enter to start game!", canvas.width/2, canvas.height/2); 
			flashingTextTimer++;
		}
        else if (flashingTextTimer2 > 0) //druga boja 30 ciklusi
		{
			my_gradient.addColorStop("0"," magenta");
		    my_gradient.addColorStop("0.5", "orange");
		    my_gradient.addColorStop("1.0", "blue");
			ctx.fillText("Click Enter to start game!", canvas.width/2, canvas.height/2); 
			flashingTextTimer2--;
        }
		else 
		{
			my_gradient.addColorStop("0"," magenta");
		    my_gradient.addColorStop("0.5", "orange");
		    my_gradient.addColorStop("1.0", "purple");
			ctx.fillText("Click Enter to start game!", canvas.width/2, canvas.height/2); 
			flashingTextTimer=0;
			flashingTextTimer2=30;
		}
		//crta player ikona pod tekstot
		ctx.drawImage(characterSpriteDefault,250,350,20,20);
		DeclareGameParameters();
	}
	power = new Power();
	function recurring() 
	{
		game.drawCanvas();
		if(!gameStarted)
			WaitForStart();
		else
		{
			power.create_power();
			power.check_collision();
			game.drawTiles();
			cloud.draw();
			randomTile.appearnow();
			randomTile.playerOnTop();
			EnemyProjectileOrder()
			EnemyOrder();
			PlayerOrder();
			ProjectileOrder();
			ScoreText();
		}
	}
	setInterval(recurring, 16.6666666667); // delenjeto sozdava stutters
	eventHandler();
	</script>
</html>