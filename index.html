<html>
	<head>
		<style>
			#canvas {
				text-align: center;
			}
		</style>
	</head>
	<body>
		<div id='canvas'>
			<canvas id="game" width="500" height="500"></canvas>
		</div>
	</body>
	<script>
	// Canvas Globals
	var canvas = document.getElementById('game');
	var ctx = canvas.getContext('2d');
	// Tile Globals
	var tiles = [];
	for (var i = 0; i < 500; i += 25) tiles.push([i, 475]);
	var firstTile = tiles[0];
	tiles.push([firstTile[0] - 25, 475]);
	// Image Globals
	var characterImage = new Image();
	var characterSpriteDefault = new Image();
	var characterSpriteWalking = new Image();
	var baseTile = new Image();
	var baseTile2 = new Image();
	var openingSlopeTile = new Image();
	var closingSlopeTile = new Image();
	var hostileInteractable = new Image();
	var neutralInteractable = new Image();
	var beneficialInteractable = new Image();
	baseTile.src = "../js13kgames_entry/tiles/2.png";
	baseTile.src = "../js13kgames_entry/tiles/1.png";
	openingSlopeTile.src = "../js13kgames_entry/tiles/3.png";
	closingSlopeTile.src = "../js13kgames_entry/tiles/4.png";
	hostileInteractable.src = "../js13kgames_entry/tiles/hostile.png";
	neutralInteractable.src = "../js13kgames_entry/tiles/neutral.png";
	beneficialInteractable.src = "../js13kgames_entry/tiles/beneficial.png";
	characterImage.src = "../js13kgames_entry/tiles/character.png";
	characterSpriteDefault.src = "../js13kgames_entry/tiles/karakter 1.png";
	characterSpriteWalking.src= "../js13kgames_entry/tiles/karakter 2.png";

	// Uncatogorized Globals
	var ImpactXInterval;
	var intervalOngoing = false;
	class Game 
	{
		constructor(canvas_width, canvas_height) 
		{
			this.gravity = true;
			this.status = 2; // 0 intro, 1 menu (selection), 2 gameplay, 3 menu during gameplay
			this.leftArr = false;
			this.upArrow = false;
			this.slope = false;
			this.canvas_width = canvas_width;
			this.canvas_height = canvas_height;
			this.primitive_tile_width = 25;
			this.primitive_tile_height = 25;
			this.className = 'Game';
		}
		drawCanvas() 
		{
			var my_gradient = ctx.createLinearGradient(0, 0, 0, 320);
			my_gradient.addColorStop(0, "darkblue");
			my_gradient.addColorStop(1, "lightblue");
			ctx.fillStyle = my_gradient;
			ctx.fillRect(0, 0, this.canvas_width, this.canvas_height);
		}
		drawTiles() 
		{
			if (this.leftArr && !randomTile.hitPlayer) //now stops moving when playa is hit by obstacle
			{ 
				var lastTile = tiles[tiles.length - 1];
				tiles.push([lastTile[0] - this.primitive_tile_width, 475]);
				for (var i = 0; i < tiles.length; i++) 
				{
					ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i][0], tiles[i][1], this.primitive_tile_width, this.primitive_tile_height);
					tiles[i][0] += player.velocity; 
				}
			} 
			else
				for (var i = 0; i < tiles.length; i++)
					ctx.drawImage(baseTile, 0, 0, 16, 16, tiles[i][0], tiles[i][1], this.primitive_tile_width, this.primitive_tile_height);
		}  
	}
	class Interactable 
	{
		constructor(status) 
		{
			this.x = parseInt(Math.random() * (400 - 100) + 100);
			this.y = parseInt(Math.random() * (400 - 100) + 100);
			this.status = status; // beneficial, neutral, hostile
			this.className = 'Interactable';
		}
		draw() 
		{
			if (this.status == 'hostile') 
				ctx.drawImage(hostileInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
			if (this.status == 'netural') 
				ctx.drawImage(neutralInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
			if (this.status == 'beneficial') 
				ctx.drawImage(beneficialInteractable, 0, 0, 16, 16, this.x, this.y, 16, 16);
		}
		ascertainCollision() 
		{
		}
		ascertainMovement()
		{
			
		}
	}
	class Player 
	{
		constructor() 
		{
			this.health = 100;
			this.w = 20;
			this.h = 30;
			this.x = 450;
			this.y = game.canvas_height - game.primitive_tile_height - this.h - 5;
			this.jumpForce = 15;
			this.verticalCollision = false;
			this.horizontalCollision = false;
			this.oldY = 0; 
			this.jumpHeight = 90;
			this.velocity = 5;
			this.gravityForce = 5;
			this.className = 'Player';
			this.enemyBounce = false;
			this.playerWasOnTop = false;
			var timerForFirstImage=0; //used in animation function to store the number of cycles the current image has been active
			var timerForSecondImage=0;
		}
		draw() 
		{
			if(game.leftArr && !randomTile.hitPlayer) // if player "moving" do the animation
			    animatePlayer(characterSpriteDefault, characterSpriteWalking, ctx, this.x,this.y,this.w,this.h);
			else
				ctx.drawImage(characterSpriteDefault,this.x,this.y,this.w,this.h);
				
		}
		jump() 
		{
			if (game.upArrow && this.verticalCollision) 
			{
				this.oldY += this.jumpForce;
				this.y -= this.jumpForce;
			}
		}
		ascertainGravity() 
		{
			if (!this.verticalCollision && !this.playerWasOnTop) //Fall if player not on ground or on top of object
			{
				this.y += 5
			}
			if (this.y+this.h >= 475 || this.playerWasOnTop) //stop falling if on ground or on object
			{
				this.jumpHeight = 90;
				this.verticalCollision = true;
				this.oldY = 0;
			} 
			else if (this.oldY === this.jumpHeight) //stop ascending when reaching max jump height
			{
				game.upArrow = false;
				this.verticalCollision = false;
			}
		}
		ascertainCollision()
		{
		}
	}
	class Projectile 
	{
		constructor(x, y, w, h) 
		{
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;
			this.ejected = false;
			this.hitEnemy = false;
			this.x_dir = 1;
			this.y_dir = -1
			this.acceleration = 7;
			this.gravityForce = 8;
			this.rotationSpeed=0;
			this.className = 'Projectile';
		}
		draw() 
		{
			if (this.ejected)
			{
				rotateAndPaintImage(ctx,neutralInteractable,this.rotationSpeed,this.x,this.y,this.w/2,this.h/2,this.w,this.h)
				this.rotationSpeed+=0.6;
			}
			else
			ctx.drawImage(neutralInteractable, 0, 0, 16, 16, this.x, this.y, this.w, this.h);	
		}
		ascertainMovement()
		{
			if (!this.ejected) 
			{
				this.x_dir = 1;
				this.y_dir = -1;
				this.x = player.x + 15; //ball stays on top of player
				this.y = player.y;
				return;
			}
			this.x += this.x_dir * this.acceleration;
			this.y += this.y_dir * this.acceleration;
		}
		ascertainCollision()
		{
            if(this.x >= game.canvas_width)
				this.x_dir *= -1;						// bounce off of right wall

			if(this.x <= 400){
				this.y_dir = 0;						// apply gravity when it reaches a certain point
				this.y += this.gravityForce;
			}
			if(this.y >= 460){
				this.ejected = false;				// dissapear when it touches the ground
			}

			if (Math.sign(Math.abs(this.x - randomTile.x)) && Math.abs(this.x - randomTile.x) < (this.w > randomTile.w ? this.w : randomTile.w) && this.y >= randomTile.y) // if hits a random tile
			{
				this.y_dir = -1;
				this.x_dir = -1; 
				return;
			}

			if (!Math.sign(Math.abs(this.x - randomTile.x)) && Math.abs(this.x - randomTile.x) < (this.w > randomTile.w ? this.w : randomTile.w) && this.y >= randomTile.y) // if hits a random tile
			{
				this.ejected = false;
				return;
			}

			
			if (Math.abs(this.x - enemy.x) < (this.w > enemy.w ? this.w : enemy.w) && this.y > enemy.y) // if hits an enemy
			{ 
				enemy.negativeCollision = true;
				this.y_dir=-1;		
				return;
			}
		}
	}

	class RandomTile 
	{
		constructor(w, tile) 
		{
			this.x = -100;
			this.w = w;
			this.h = 40; // random object height
			this.y = 445 - (30 * (this.h / 30 - 1)); //makes sure object is always above ground
			this.tile = tile;
			this.random = 0;
			this.hitPlayer = false;
			this.playerWasOnTop = false; //tells the player if the player is on top of object
			this.className = 'RandomTile';
		}

		appearnow() 
		{
			ctx.drawImage(this.tile, this.x, this.y, this.w, this.h);
			if (game.leftArr && !this.hitPlayer) this.x += player.velocity;
			if (this.x > 600)
			{
				this.appear = false; //appearn() will stop being called
				this.w=20 * Math.floor((Math.random()*5)+1) //must be bigger than 20 and divisible by 20
				this.x = -100; // reset at original position on the left
				this.h = 10+10*Math.floor((Math.random()*5)+1); //new object height //must at least 20 and divisible by 10
				this.y = 445 - (30 * (this.h / 30 - 1)); //adjust y to new height   
			}
			if (Math.abs(this.x - player.x) == this.w   && player.x > this.x) //when player and object collide on x axis
			{
				if (player.y + player.h / 2 > (this.y - this.h / 2)) this.hitPlayer = true; // if player isnt in the air over the obstacle
				else this.hitPlayer = false;
			}
		}
		playerOnTop() 
		{
			if (Math.abs(this.y - player.y) == 30 && Math.abs(this.x - player.x) < this.w &&player.x > this.x-20)
				player.playerWasOnTop = true;
			else if (player.playerWasOnTop) 
			{
				player.playerWasOnTop = false;
				if (!game.upArrow) 
				{
					game.upArrow = false;
					player.verticalCollision = false;
				}
			}
		}
	}
	class Enemy 
	{
		constructor() 
		{
			this.w = player.w * 2;
			this.h = player.h * 1.5;
			this.x = 250;
			this.y = game.canvas_height - game.primitive_tile_height - this.h - 5;
			this.maxLives=3;
			this.currentLives = this.maxLives;
			this.verticalCollision = false;
			this.negativeCollision = false;
			this.className = 'Enemy';
		}
		draw() 
		{
			ctx.fillStyle = 'black';
			ctx.fillRect(this.x, this.y, this.w, this.h)
		}
		fall() 
		{
			if (!this.verticalCollision && !this.playerWasOnTop) 
			{
				this.y += 5;
			}
			if (this.y >= 445 + (30 - this.h)) 
				this.verticalCollision = true;
			else 
				this.verticalCollision = false;
		}
		move() 
		{
			if (game.leftArr && !randomTile.hitPlayer)
				this.x += player.velocity;
		}
		ascertainCollision() 
		{
			if (this.x > 500)
			{
				this.respawn();
				return;
			}
			
			if (this.negativeCollision && projectile.ejected) // projectile collision
			{
				projectile.ejected = false;
				this.negativeCollision = false;
				this.currentLives--;
				if (this.currentLives < 1)
					return this.respawn();
				ImpactX(enemy, 15);
				return;
			}
			
			if (Math.abs(this.x - randomTile.x) <= (this.w > randomTile.w ? this.w : randomTile.w)) // random tile collision
			{
				clearInterval(ImpactXInterval);
				intervalOngoing = false;
				return;
			} 

			if (Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y == player.y + player.h) // player Y collision causes a bounce
			{
				player.jumpHeight = 180;
				player.verticalCollision = true;
				game.upArrow = true;
				return;
			}
			
			if (Math.abs(this.x - player.x) < (this.w > player.w ? this.w : player.w) && this.y < player.y + player.h) // player X collision
			{
				ImpactX(randomTile, 15, true);
				ImpactX(enemy, 15, true);
				ImpactX(tiles, 15, true);
				return;
			}
		}
		respawn() 
		{
			this.x = randomTile.x - 200;
			this.y = game.canvas_height - this.h - game.primitive_tile_height;
			this.currentLives = this.maxLives;
		}

		healthbar()
		{
			ctx.fillStyle = 'gray';
			ctx.fillRect(this.x, this.y-this.w/3, this.w, 10);
			if (this.currentLives == 1)
				ctx.fillStyle = 'red';
			else ctx.fillStyle = 'green';
			ctx.fillRect(this.x, this.y-this.w/3, this.w * ((this.currentLives*100/this.maxLives)/100), 10);
		}
	}
	game = new Game(500, 500);
	randomTile = new RandomTile(100, baseTile);
	player = new Player();
	enemy = new Enemy();
	projectile = new Projectile(10, 10, 10, 10);

	function eventHandler() 
	{
		window.addEventListener('keydown', function(event) 
		{
			if (event.keyCode == 38) // up
			{
				game.upArrow = true;
			}
			if (event.keyCode == 32) // space
			{
				projectile.ejected = true;
			}
			if (event.keyCode == 37) // left
			{
				game.leftArr = true;
	 		}
		}, false);
		window.addEventListener('keyup', function(event) 
		{
			if (event.keyCode == 37) // left
			{
				game.leftArr = false
			}

		}, false);
	}

	function ImpactX(entity, repetitions, reverse = false) 
	{
		if (intervalOngoing) return;
		intervalOngoing = true;
		let x = 0;
		ImpactXInterval = window.setInterval(function () 
		{
			if (reverse) 
			{
				game.upArrow = true;
				player.velocity = -10;
			}
			else 
			{
				entity.x -= 10;
			}

			if (++x === repetitions) 
			{
				if (reverse) player.velocity = 5;

				intervalOngoing = false;
				window.clearInterval(ImpactXInterval);
			}
		}, 16.6666666667);
	}
	
	function animatePlayer( defaultImage, walkingImage, context) {
	  if(player.timerForFirstImage<5) {  //crta prvata slika 5 ciklusi
	    context.drawImage(defaultImage,player.x,player.y,player.w,player.h);
		player.timerForFirstImage++;
	  }
	  else if(player.timerForSecondImage<5) { //crta vtorata slika 5 ciklusi
	    context.drawImage(walkingImage,player.x,player.y,player.w,player.h);
		player.timerForSecondImage++
	  }
	  else { //resetira, so sho ke pocni da ja crta prvata slika povtorno
		context.drawImage(defaultImage,player.x,player.y,player.w,player.h);
		player.timerForFirstImage=0
		player.timerForSecondImage=0;
	  }		
}

	function rotateAndPaintImage ( context, image, angleInRad , positionX, positionY, axisX, axisY, width, height ) 
	{
        context.translate( positionX, positionY );
        context.rotate( angleInRad );
        context.drawImage( image, -axisX, -axisY, width, height );
        context.rotate( -angleInRad );
        context.translate( -positionX, -positionY );
	}
	function EnemyOrder() 
	{
		enemy.draw();
		enemy.healthbar();
		enemy.fall();
		enemy.move();
		enemy.ascertainCollision();
	}
	function ProjectileOrder() 
	{
		projectile.ascertainMovement();
		projectile.ascertainCollision();
		projectile.draw();
	}
	function PlayerOrder() 
	{
		player.ascertainGravity();
		player.jump();
		player.draw();
	}
	function recurring() 
	{
		game.drawCanvas();
		game.drawTiles();
		randomTile.appearnow();
		randomTile.playerOnTop();
		PlayerOrder();
		EnemyOrder();
		ProjectileOrder();
	}
	setInterval(recurring, 16.6666666667); // delenjeto sozdava stutters
	eventHandler();
	</script>
</html>